<!DOCTYPE html>
<html lang="cn">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>一些知识</title>
    <!-- 引入 Bootstrap CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-T3c6CoIi6uLrA9TneNEoa7RxnatzjcDSCmG1MXxSR1GAsXEV/Dwwykc2MPK8M2HN" crossorigin="anonymous">
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/js/bootstrap.bundle.min.js" integrity="sha384-C6RzsynM9kWDrMNeT87bh95OGNyZPhcTNXj1NW7RuBCsyN/o0jlpcV8Qyq46cDfL" crossorigin="anonymous"></script>
    <link rel="stylesheet" type="text/css" href="/assets/css/Comm/CommStyle.css">
    <link rel="stylesheet" type="text/css" href="/assets/css/defaultpagelist.css">
    <link rel="stylesheet" href="/assets/css/syntax.css">
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
</head>
<body>
    <div id="sidebar">
        <!-- 个人信息部分 -->
        <div id="personal-info">
            <h3>一个路过的假人</h3>
            <p style="font-size: 12px;color: lightgray;">一个掌握了各种技能的嵌入式软件工程师</p>
            <p>总感觉你们在背着我学习</p>
            
        </div>
        <hr>
        <!-- 描述 -->
        <div margin="10px">
            <table id="personal-data">
                <tr>
                    <td>经验值: </td>
                    <td>10</td>
                </tr>
                <tr>
                    <td>状态: </td>
                    <td> 存在</td>
                </tr>
                <tr>
                    <td>访问量</td>
                    <td><span id="busuanzi_value_site_uv"></span></td>
                </tr>
            </table>
        </div>
        <hr>
        <!-- 链接 -->
        <div id="container">
            <ul>
                <li><a href="/index.html" id="link-setting" >HOME</a></li>
                <li>
                    <a href="/assets/web/gameindex/gamepage.html" id="link-setting">
                        <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" fill="currentColor" class="bi bi-cup-straw" viewBox="0 0 16 16">
                            <path d="M13.902.334a.5.5 0 0 1-.28.65l-2.254.902-.4 1.927c.376.095.715.215.972.367.228.135.56.396.56.82 0 .046-.004.09-.011.132l-.962 9.068a1.28 1.28 0 0 1-.524.93c-.488.34-1.494.87-3.01.87-1.516 0-2.522-.53-3.01-.87a1.28 1.28 0 0 1-.524-.93L3.51 5.132A.78.78 0 0 1 3.5 5c0-.424.332-.685.56-.82.262-.154.607-.276.99-.372C5.824 3.614 6.867 3.5 8 3.5c.712 0 1.389.045 1.985.127l.464-2.215a.5.5 0 0 1 .303-.356l2.5-1a.5.5 0 0 1 .65.278zM9.768 4.607A13.991 13.991 0 0 0 8 4.5c-1.076 0-2.033.11-2.707.278A3.284 3.284 0 0 0 4.645 5c.146.073.362.15.648.222C5.967 5.39 6.924 5.5 8 5.5c.571 0 1.109-.03 1.588-.085l.18-.808zm.292 1.756C9.445 6.45 8.742 6.5 8 6.5c-1.133 0-2.176-.114-2.95-.308a5.514 5.514 0 0 1-.435-.127l.838 8.03c.013.121.06.186.102.215.357.249 1.168.69 2.438.69 1.27 0 2.081-.441 2.438-.69.042-.029.09-.094.102-.215l.852-8.03a5.517 5.517 0 0 1-.435.127 8.88 8.88 0 0 1-.89.17zM4.467 4.884s.003.002.005.006l-.005-.006zm7.066 0-.005.006c.002-.004.005-.006.005-.006zM11.354 5a3.174 3.174 0 0 0-.604-.21l-.099.445.055-.013c.286-.072.502-.149.648-.222z"/>
                        </svg>
                    </a>
                </li>
                <li><a href="/about.html" id="link-setting" >ABOUT</a></li>
                <div class="bar"></div>
            </ul>
        </div>
        
    </div>
    <div id="bar-setting">
    <div id="bar-content">
        <nav style="--bs-breadcrumb-divider: '>';" aria-label="breadcrumb">
            <ol class="breadcrumb">
            <li class="breadcrumb-item"><a class="link-info" href="/index.html">Home</a></li>
            
            <li class="breadcrumb-item"><a class="link-info" href="/classes/rtos_series.html">从零开始设计RTOS</a></li>
            <li class="breadcrumb-item active" aria-current="page">从零开始设计RTOS - 第一章 上下文切换</li>
            </ol>
        </nav>
    </div>
</div>

<div id="content">
    <div id="post-setting">
        <h1>从零开始设计RTOS - 第一章 上下文切换</h1>
        <div id="post-time">2023-10-25</div>
        <hr>
    
        <p>在一个操作系统上，可以运行着很多程序。而这些看似同时运行，实际上是每个程序轮流使用一段时间，就像斗地主发牌一样，一张张地发给每一个玩家，但只要同时发给三个玩家的速度足够快，就会感觉同时一次发出了三张牌。这种实现方式叫做分时复用。</p>

<p>在一段很短的时间内，每个程序轮流被运行一次，轮流使用各种资源。如图1.0.1。</p>

<p>图1.0.1</p>

<p>一般设备运行频率很快，快到在一段时间内，轮流执行了一遍的程序，看起来像是同时运行一样。</p>

<p>像这样将程序轮流执行的功能，在操作系统上，是通过任务调度完成的。任务调度是实现在较短时间内切换任务的核心功能，就像日程表一样，早上背单词，下午写文章，晚上去跑步。在任务切换的过程中，就像根据日程表做下一件事一样——记住早上单词背到哪，下午继续写昨天还没写完的文章，任务调度需要保存当前任务的运行状态，和恢复下一个任务已经运行到的状态。</p>

<p>图</p>

<p>这么一个过程叫做上下文切换——保存上文和恢复下文。
‑ 保存上文，在任务调度后需要变更执行任务时，保存CPU的各个寄存器到当前任务栈空间的过程，就跟游戏存档一样。
‑ 恢复下文，变更执行任务时，把目标任务的栈空间之前保存的值恢复到CPU的各个寄存器中，就跟游戏读档一样。</p>

<p>本章将介绍程序在CPU运行的原理、上下文切换的原理和STM32针对操作系统在硬件上所做的优化机制。同时，实现一个简单的上下文切换机制，来控制引脚的切换。</p>

<hr />

<h3 id="1cpu的运行原理">1.CPU的运行原理</h3>

<p>在STM32中，程序代码、定义的常量和初始化的全局变量烧写在片上FLASH中；STM32是哈佛体系架构，程序和数据分开存储，在运行的时候变量被搬运到片上RAM中，而程序代码在FLASH中，于是CPU执行的代码从片上FLASH中读取，数据在RAM中读取。CPU在执行时，需要相关的寄存器。</p>

<p>在Cortex‑M3的内部寄存器组：</p>
<ul>
  <li>通用寄存器R0～R7，低组寄存器。所有指令都能访问他们。长度为32位，复位后的初始值不可预知。</li>
  <li>通用目的寄存器R8～R12，高组寄存器。很少的16位Thumb指令能访问他们，32位Thumb-2指令则不受限制。长度为32位，复位后的初始值不可预知。</li>
  <li>堆栈指针R13（SP），在M3处理器内核中共有两个堆栈指针，能支持两个堆栈。堆栈指针的最低两位永远为0，即总是4字节对齐。</li>
  <li>主堆栈指针（MSP），复位后缺省堆栈指针，由OS内核、异常服务例程以及所有  需要特权访问的应用程序代码来使用。</li>
  <li>进程堆栈指针（PSP），用于常规的应用程序代码。</li>
  <li>链接寄存器R14（LR），当调用子程序时，由R14存储返回地址；如果子程序多于1    级，则需要把前一级的R14压入堆栈。</li>
  <li>程序计数器R15（PC），读取PC值，返回当前指令地址+4；修改它，能改变程序的执行流</li>
  <li>程序状态寄存器（PSRs或xPSR），内部分为3个子状态寄存器。</li>
  <li>应用程序PSR（APSR），</li>
  <li>中断号PSR（IPSR），处于线程模式时，该域为0；其他，该域为当前异常的异常号。</li>
  <li>执行PSR（EPSR），Thumb状态值为1；ARM状态值为0.</li>
  <li>中断屏蔽寄存器，</li>
  <li>PRIMASK，置1后，关闭所有可屏蔽中断的异常，只剩NMI和硬件fault，默认值为0。</li>
  <li>FAULTMASK，置1，屏蔽除NMI外的所有异常（包括硬fault），默认值为0。</li>
  <li>BASEPRI，寄存器长度9位，它定义了被屏蔽优先级的阈值；当它设定为莫个值后，所有优先级号大于等于此值的中断都被关闭；当它设为0，则不关闭任何中  断，默认值为0。</li>
  <li>控制寄存器（CONTROL），[1]位为0表示选择MSP，为1表示选择PSP；[2]位为0表示特权级线程模式，为1表示用户级线程模式。</li>
</ul>

<p>如何将指令装载到处理器中执行，由PC寄存器决定。指令流水线根据PC的值从内存中获取指令后，PC寄存器的值会自加以获取下一条指令。修改PC寄存器的值，可以实现跳转功能，进而实现分支语句和函数调用等语言特性。</p>

<p>在现代的程序结构中，会用到其他函数。处理器在调用完其他函数后，需要返回调用其他函数之前的函数继续执行指令。而这保存和恢复处理器状态的功能，是由栈机制实现。栈机制是由处理器通过一个栈指针寄存器（SP）提供。</p>

<p>在内存中，开辟一块空间作为栈空间，SP指向栈顶。通过压栈和出栈的方式向栈空间存取数据。在STM32中，压入的数据，从栈顶开始入栈，SP自减指向下一个可用地址，继续入栈。出栈时，SP自加，数据一个个取出。</p>

<p>入栈出栈的后进先出（LIFO）特性，可以实现调用完函数后，恢复执行调用该函数之前的操作。</p>

<hr />

<h3 id="2上下文切换的原理">2.上下文切换的原理</h3>

<p>在操作系统中，每个任务是相互独立的，每个任务不一定是连续的装载在内存中，每个任务所在的内存地址都不相同。在运行的时候，需要实现多任务的功能，任务与任务间需要切换操作，也就是上下文切换。</p>

<p>根据CPU的运行原理，由任务调度器将CPU各寄存器的值压入栈空间，实现上文保存；再将栈指针（SP）指向目标任务的栈空间地址的栈顶，然后依次把各个寄存器的值出栈，实现恢复下文。</p>

<hr />

<h3 id="3stm32的优化机制">3.STM32的优化机制</h3>

<p>Cortex‑M系列在设计的过程，为操作系统做了一些优化。</p>

<p>提供了两个栈指针MSP和PSP，前者通常在操作系统内核和中断服务中使用；后者则用于任务中。任一时刻，只能使用其中一个堆栈指针。</p>

<p>PendSV，编号为14的异常中断，中断优先级可配置，一般会把优先级配置为最低。可以向中断控制与状态寄存器(SCB‑&gt;ICSR)的bit28写1触发。</p>

<p>PendSV中断服务函数一般执行上下文切换的功能，也是任务堆栈部分切换的核心。</p>

<p>在早起的操作系统中，需要先检测当前是否有中断服务在进行中，如果有上文切换将推迟到下个调度周期，直到没有任何中断在响应时，才会执行上下文切换（切换期间无法响应）。因为在Cortex‑M3中，在有中断服务进行的时候，执行上下文切换，会触犯用法Fault异常。</p>

<p>但是，这种方法会有一个坏处，当有中断的频率和系统调度的频率接近时，会使上下文切换一直被推迟，甚至无法执行。</p>

<p>PendSV的出现，很好地解决了这个问题，因为PendSV的中断优先级配置为最低，可以自动延迟上下文切换的请求，等待其他中断服务都完成了才执行，所以系统对于中断可以及时响应，满足系统实时性的要求。</p>

<p>图1.3.1 描述了利用PendSV切换上下文的过程。</p>

<p>图</p>

<ol>
  <li>任务A正在执行时触发了一个中断1。</li>
  <li>系统响应中断1，进入中断服务函数。</li>
  <li>在中断服务函数执行的时候，系统调度被触发。</li>
  <li>进入系统调度，做好上下文切换的准备，悬起PendSV中断。</li>
  <li>退出系统调度，继续执行中断服务函数。</li>
  <li>退出中断服务函数，响应PendSV中断，执行上下文切换。</li>
  <li>PendSV执行完成，进入任务B。</li>
  <li>在执行任务B的时候，系统调度被触发。</li>
  <li>进入系统调度，做好上下文切换的准备，悬起PendSV中断。</li>
  <li>退出系统调度，响应PendSV中断，执行上下文切换。</li>
  <li>PendSV执行完成，进入任务A。</li>
</ol>

<hr />

<h3 id="4上下文机制的实现">4.上下文机制的实现</h3>

<p>首先，在PendSV中断服务函数中，实现上下文切换的代码。这部分代码需要用汇编实现。</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre></td><td class="code"><pre>;中断服务函数(Code A)
PendSVHandler
    CPSID I    ;关中断
    MRS    R0, PSP                     ;用MRS指令将当前PSP的值保存到R0中
    CBZ    R0, z_load_below            ;R0的值为零，跳转，加载下文

    SUBS    R0, R0, #0x20              ;R0=R0‑0x20，将PSP栈地址向下偏移0x20
                                       ;给8个寄存器腾出空间，一个占4字节
    STM    R0, {R4‑R11}                ;保存R4‑R11到当前栈空间中

    LDR    R1, =z_core_TCBp_Current    ;R1=z_core_TCBp_Current
    LDR    R1, [R1]                    ;R1=(*z_core_TCBp_Current)
    STR    R0, [R1]                    ;z_core_TCBp_Current‑&gt;SP=R0

    z_load_below
    LDR    R0, =z_core_TCBp_Current    ;R0=z_core_TCBp_Current
    LDR    R1, =z_core_TCBp_HighRdy    ;R1=z_core_TCBp_HighRdy
    LDR    R2, [R1]                    ;R2=(*z_core_TCBp_HighRdy)
    STR    R2, [R0]                    ;(*z_core_TCBp_Current)=R2

    LDR    R0, [R2]                    ;R0=z_core_TCBp_HighRdy
    LDM    R0, {R4‑R11}                ;将HighRdy栈空间的值出栈到R4‑R11
    ADDS    R0, R0, #0x20              ;R0=R0+0x20，将栈地址向上偏移0x20

    MSR    PSP, R0                     ;加载z_core_TCBp_HighRdy堆栈到PSP
    ORR    LR, LR, #0x40               ;确保返回时使用PSP作为栈指针
    CPSIE I                            ;开中断
    BX    LR                           ;中断返回将恢复剩余的上下文
</pre></td></tr></tbody></table></code></pre></figure>

<p>分为保存上文和恢复下文两部分。<br />
保存上文中</p>
<ol>
  <li>判断上文栈指针是否为0，为0则直接进入恢复下文部分。</li>
  <li>进入中断后，会自动将xPSR, PC, LR, R11, R0-R3压栈，剩余的R4-R11通过汇编压入栈中</li>
  <li>更新任务栈指针。</li>
</ol>

<p>恢复下文，与保存上文顺序相反</p>
<ol>
  <li>获取要切换的任务栈指针。</li>
  <li>通过汇编从栈空间恢复R4-R11寄存器的值。</li>
  <li>更新PSP任务栈指针，退出中断服务函数进入任务，使用PSP作为栈指针。
Cortex-M3中，堆栈寄存器有两个指针。MSP为复位后缺省使用的，中断中永远使用
MSP。要使用PSP，则需要手动开启。由这部分实现。</li>
</ol>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre>MSR PSP, R0
ORR LR, LR, #0x04
</pre></td></tr></tbody></table></code></pre></figure>

<p>将LR的位2置为1后，在中断返回后，任务使用PSP。</p>

<p>在执行上下文切换的时候，不可被中断切换，所以在进入PendSV中断服务函数的时候，关闭中断，结束的时候开启中断。</p>

<p>设置PendSV中断的部分，也有汇编编写：</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre></td><td class="code"><pre>;PendSV中断配置部分
NVIC_INT_CTRL EQU 0xE000ED04 ;PendSV中断控制寄存器
NVIC_SYSPRI14 EQU 0xE000ED22 ;系统优先级寄存器
NVIC_PENDSV_PRI EQU 0xFF ;PendSV的优先级‑最低值
NVIC_PENDSVSET EQU 0x10000000 ;第24位为PendSV触发位

;系统启动，开启PendSV中断(Code B)
zOS_start
    ;设置PendSV优先级为0xFF(最低值)
    LDR R0, =NVIC_SYSPRI14
    LDR R1, =NVIC_PENDSV_PRI
    STRB R1, [R0]

    ;将进程堆栈指针设为0
    MOVS R0, #0
    MSR PSP, P0

    ;将主堆栈指针的值设为z_core_ExceptStkBass栈顶
    LDR R0, =z_core_ExceptStkBass
    LDR R1, [R0]
    MSR MSP, R1

    ;触发PendSV中断服务函数，开启运行OS
    LDR R0, =NVIC_INT_CTRL
    LDR R1, =NVIC_PENDSVSET
    STR R1, [R0]

    ;启动中断
    CPSIE I
</pre></td></tr></tbody></table></code></pre></figure>

<p>触发PendSV中断实现上下文切换部分。</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre></td><td class="code"><pre>;上下文切换(Code C)
z_content_switch
    LDR R0, =NVIC_INT_CTRL
    LDR R1, =NVIC_PENDSVSET
    STR R1, [R0]
    ;返回
    BX LR
</pre></td></tr></tbody></table></code></pre></figure>

<p>这些就是实现上下文切换的机制,文件名：z_asm.s，整体格式如下：</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre></td><td class="code"><pre>;PendSV中断配置部分
NVIC_INT_CTRL EQU 0xE000ED04 ;PendSV中断控制寄存器
NVIC_SYSPRI14 EQU 0xE000ED22 ;系统优先级寄存器
NVIC_PENDSV_PRI EQU 0xFF ;PendSV的优先级‑最低值
NVIC_PENDSVSET EQU 0x10000000 ;第24位为PendSV触发位

;对接C语言的相关变量
EXTERN z_core_ExceptStkBass
EXTERN z_core_TCBp_Current
EXTERN z_core_TCBp_HighRdy
;声明函数
EXPORT zOS_start
EXPORT PendSVHandler
EXPORT z_content_switch

zOS_start
    ;(code B)

zOS_start_hang
    B zOS_start_hang

PendSVHandler
    ;(code A)

z_content_switch
    ;(Code C)
</pre></td></tr></tbody></table></code></pre></figure>

<hr />

<h3 id="5-c语言实现">5.	C语言实现</h3>

<p>在汇编中，有几个变量。</p>

<figure class="highlight"><pre><code class="language-asm" data-lang="asm"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre>EXTERN z_core_ExceptStkBass
EXTERN z_core_TCBp_Current
EXTERN z_core_TCBp_HighRdy
</pre></td></tr></tbody></table></code></pre></figure>

<p>它们需要在C语言中实现，其中 z_core_ExceptStkBass 定义一个主堆栈区，用于MSP堆栈指针；z_core_TCBp_Current 为当前正在执行的任务堆栈地址，z_core_TCBp_HighRdy 为将要执行的任务堆栈地址。
这两个具体是一个结构体:</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="code"><pre><span class="n">z_STK_t</span><span class="o">*</span> <span class="n">z_core_ExceptStkBass</span><span class="p">;</span>
<span class="n">z_core_TCBp_t</span> <span class="n">z_core_TCBp_Current</span><span class="p">;</span>
<span class="n">z_core_TCBp_t</span> <span class="n">z_core_TCBp_HighRdy</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>其中，z_STK_t 在 z_def.h 文件中定义。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_uint32_t</span><span class="p">;</span> <span class="c1">//4字节数据类型</span>
<span class="k">typedef</span> <span class="n">z_uint32_t</span> <span class="n">z_STK_t</span><span class="p">;</span> <span class="c1">//栈类型</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>z_core_TCBp_t 在 z_core.h 文件中定义。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
</pre></td><td class="code"><pre><span class="c1">//任务控制块</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">z_core_TaskControlBlock</span><span class="p">{</span>
<span class="n">z_STK_t</span> <span class="o">*</span><span class="n">SP</span><span class="p">;</span> <span class="c1">//栈顶地址</span>
<span class="p">}</span><span class="n">z_core_TCB_t</span><span class="p">,</span><span class="o">*</span><span class="n">z_core_TCBp_t</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>在C语言中，结构体的地址，也是结构体内部的第一个变量的地址。所以当汇编中调用 z_core_TCBp_Current 和 z_core_TCBp_HighRdy 这两个时，都是调用内部 SP 的值。</p>

<p>利用这个特性，可以在这个结构体中添加任务相关的信息——优先级，时间片，任务名称，任务状态等等。</p>

<p>这样，可以做一个简易的切换函数。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre></td><td class="code"><pre><span class="k">extern</span> <span class="kt">void</span> <span class="nf">z_content_switch</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="n">z_core_TCB_t</span> <span class="n">TCBs</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">//定义两个任务控制快。</span>
<span class="kt">void</span> <span class="nf">z_core_switch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">z_core_TCBp_Current</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
    <span class="p">{</span>
        <span class="n">z_core_TCBp_HighRdy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="n">z_core_TCBp_HighRdy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">z_content_switch</span><span class="p">();</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>当前的任务控制块地址为 TCBs[0] 的地址时，将 TCBs[1] 的地址复制到 z_core_TCBp_HighRdy 准备进行切换；当为 TCBs[1] 的地址时，则将 TCBs[0] 的地址赋值到z_core_TCBp_HighRdy 进行准备切换。并调用 z_content_switch() 触发PendSV中断服务函数，进行上下文切换。</p>

<p>任务控制块的 SP 栈顶指针需要赋予一个具体的地址，这个地址将由数组来充当堆栈提供。堆栈里面存储相应的CPU寄存器地址和运行时变量，调用的函数等数据。</p>

<p>在STM32中栈指针是向下的，每次的压栈操作，SP指针都会自减，出栈时会自加。这部分的实现如下。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre></td><td class="code"><pre><span class="kt">void</span> <span class="nf">z_core_add</span><span class="p">(</span><span class="n">z_core_TCB_t</span> <span class="o">*</span><span class="n">_tcb</span><span class="p">,</span><span class="n">entry_t</span> <span class="n">_entryfunc</span><span class="p">,</span> <span class="n">z_STK_t</span> <span class="o">*</span><span class="n">_stk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">z_STK_t</span> <span class="o">*</span><span class="n">p_stk</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">p_stk</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="o">*</span><span class="p">)(((</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">_stk</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFFFFFFF8u</span><span class="p">);</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_xPSR</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">_entryfunc</span><span class="p">;</span>      <span class="c1">//函数进口</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">z_core_end</span><span class="p">;</span>	  <span class="c1">//任务结束回调程序</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R12</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R3</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R2</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R1</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R0</span><span class="p">;</span>

    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R11</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R10</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R9</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R8</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R7</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R6</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R5</span><span class="p">;</span>
    <span class="o">*</span><span class="p">(</span><span class="o">--</span><span class="n">p_stk</span><span class="p">)</span>  <span class="o">=</span> <span class="p">(</span><span class="n">z_STK_t</span><span class="p">)</span><span class="n">CPU_DEFINE_R4</span><span class="p">;</span>

    <span class="n">_tcb</span><span class="o">-&gt;</span><span class="n">SP</span> <span class="o">=</span> <span class="n">p_stk</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>输入参数 _tcb 为任务控制块的地址，_entryfunc 为任务函数入口，_stk 为堆栈地址。</p>

<p>entry_t 在 z_core.h 文件中定义。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
</pre></td><td class="code"><pre><span class="c1">//入口函数类型</span>
<span class="k">typedef</span> <span class="nf">z_err_t</span> <span class="p">(</span><span class="o">*</span><span class="n">entry_t</span><span class="p">)(</span><span class="kt">void</span><span class="o">*</span> <span class="n">_parameter</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>寄存器的宏定义部分，则在 z_def.h 中实现。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="c1">//堆栈相关寄存器地址</span>
<span class="cp">#define	CPU_DEFINE_xPSR   0x01000000uL
#define	CPU_DEFINE_R0     0x00000000uL
#define	CPU_DEFINE_R1     0x01010101uL
#define	CPU_DEFINE_R2     0x02020202uL
#define	CPU_DEFINE_R3     0x03030303uL
#define	CPU_DEFINE_R4     0x04040404uL
#define	CPU_DEFINE_R5     0x05050505uL
#define	CPU_DEFINE_R6     0x06060606uL
#define	CPU_DEFINE_R7     0x07070707uL
#define	CPU_DEFINE_R8     0x08080808uL
#define	CPU_DEFINE_R9     0x09090909uL
#define	CPU_DEFINE_R10    0x10101010uL
#define	CPU_DEFINE_R11    0x11111111uL
#define	CPU_DEFINE_R12    0x12121212uL</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>这些基本的结构，就能实现最简易的任务切换的功能了。整体部分如下。</p>

<p>z_def.h 文件中。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre></td><td class="code"><pre><span class="cp">#ifndef __Z_DEF_H__
#define __Z_DEF_H__
</span><span class="c1">//堆栈相关寄存器地址</span>
<span class="cm">/* 代码实现 */</span>

<span class="cm">/* 常规类型定义 */</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">z_uint8_t</span><span class="p">;</span>
<span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">z_uint32_t</span><span class="p">;</span>

<span class="cm">/* 内核相关类型定义 */</span>
<span class="k">typedef</span> <span class="n">z_uint32_t</span> <span class="n">z_STK_t</span><span class="p">;</span> <span class="c1">//栈类型</span>
<span class="cp">#endif</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>z_core.h 文件中。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre></td><td class="code"><pre><span class="cp">#ifndef __Z_CORE_H__
#define __Z_CORE_H__
</span>
<span class="cp">#include</span> <span class="cpf">"z_def.h"</span><span class="cp">
</span>
<span class="c1">// define ‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑‑</span>
<span class="c1">//入口函数类型</span>
<span class="k">typedef</span> <span class="nf">void</span> <span class="p">(</span><span class="o">*</span><span class="n">entry_t</span><span class="p">)(</span><span class="kt">void</span><span class="p">);</span>

<span class="c1">//任务控制块</span>
<span class="k">typedef</span> <span class="k">struct</span><span class="p">{</span>
<span class="n">z_STK_t</span> <span class="o">*</span><span class="n">SP</span><span class="p">;</span>      <span class="c1">//栈顶地址</span>
<span class="p">}</span><span class="n">z_core_TCB_t</span><span class="p">,</span><span class="o">*</span><span class="n">z_core_TCBp_t</span><span class="p">;</span>

<span class="cp">#endif</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>z_core.c 文件中。</p>

<figure class="highlight"><pre><code class="language-c" data-lang="c"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
</pre></td><td class="code"><pre><span class="c1">//任务2</span>
<span class="kt">void</span> <span class="nf">fun2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">z_uint8_t</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">j</span><span class="o">++</span><span class="p">;</span>
        <span class="n">z_core_switch</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">z_core_switch</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 代码实现 */</span>
<span class="p">}</span>

<span class="c1">//任务结束时调用到的函数</span>
<span class="kt">void</span> <span class="nf">z_core_end</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{}</span>

<span class="c1">//任务添加</span>
<span class="kt">void</span> <span class="nf">z_core_add</span><span class="p">(</span><span class="n">z_core_TCB_t</span> <span class="o">*</span><span class="n">_tcb</span><span class="p">,</span><span class="n">entry_t</span> <span class="n">_entryfunc</span><span class="p">,</span> <span class="n">z_STK_t</span> <span class="o">*</span><span class="n">_stk</span><span class="p">)</span>
<span class="p">{</span>
    <span class="cm">/* 代码实现 */</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//添加第一个任务</span>
    <span class="n">z_core_add</span><span class="p">(</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">fun1</span><span class="p">,</span><span class="o">&amp;</span><span class="n">FunStack1</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>
    <span class="c1">//添加第二任务</span>
    <span class="n">z_core_add</span><span class="p">(</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span><span class="n">fun2</span><span class="p">,</span><span class="o">&amp;</span><span class="n">FunStack2</span><span class="p">[</span><span class="mi">31</span><span class="p">]);</span>
    <span class="c1">//准备启动第一个任务</span>
    <span class="n">z_core_TCBp_HighRdy</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TCBs</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

    <span class="c1">//运行</span>
    <span class="n">zOS_start</span><span class="p">();</span>

    <span class="k">while</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></figure>

<p>在下一章，将丰富这部分功能，实现简单的任务调度功能，具有优先级，延迟等功能。</p>


    </div>

    <button type="menu" class="btn btn-light" id="scrollToTop">Top</button>

    <script src="/assets/js/topbtn_script.js"></script>
</div>
</body>
</html>
