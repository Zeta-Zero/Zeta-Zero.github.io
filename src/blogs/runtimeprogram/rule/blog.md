
zSlip用语言，旨在提供一种可以运行在性能紧凑的设备上的运行时编译语言，可以在裸机，不包含或包含RTOS的设备上运行。  
在微控制器上，增加编程的灵活度，降低编程的难度。

******

# 1. 基本语法

## 1.0 关键字 符号

保留关键字不能作为常量或变量或其他用户自定义标示符

<table>
 <tr>
   <td>let</td><td>const</td><td>local</td><td>global</td>
   <td>null</td><td>obj</td><td>num</td><td>float</td>
 </tr>
 <tr>
   <td>bool</td><td>string</td><td>fn</td><td>map</td>
   <td>for</td><td>break</td><td>do</td><td>while</td>
 </tr>
 <tr>
   <td>if</td><td>else</td><td>elif</td><td>switch</td>
   <td>case</td><td>default</td><td>true</td><td>false</td>
 </tr>
 <tr>
   <td>return</td><td>and</td><td>or</td><td>not</td>
   <td>infinite</td><td>bit</td><td>byte</td><td></td>
 </tr>
</table>

使用的符号

|符号类型|描述|
|---|---|
|**;**|分号是语句结束符，表明一个逻辑实体的结束。|
|**{}**|一对大括号是代码块的标识符，表明一个代码运行区域。|
|**//**|双斜杠代表单行注释，从该符号开始到行结束都是注释内容，不参与运行|
|**/\*\*/**|多行注释标识符，从 **/\*** 开始，到 **\*/** 结束，该区域内容为注释内容，不参与运行|



## 1.1 数据类型

zSlip是动态类型语言，但变量被显式声明时，变量类型为静态类型。数值/数据，可以储存在变量中、作为参数传递或返回结果。
zSlip有2个基础类型：null,obj；和8个基于obj的基本类型。

### 1.1.1 基本类型

|数据类型|基于类型|描述|
|---|---|---|
|null|-|表示一个无效的值，一旦声明，会被释放所有资源|
|obj|-|一个基础的数据结构，包含数据大小，数据内容|
|bool|obj|仅包含两个值，false和true；0和false等价，非0和true等价|
|bit|obj|位，只有0和1|
|byte|obj|字节，范围0-255|
|num|obj|整数类型，无限制，可大数运算，包含正负数据|
|float|obj|双精度类型的浮点数，包含正负数据|
|string|obj|字符串，声明在 **""** 或 **''** 中的数据皆为字符串数据|
|fn|obj|函数声明|
|map|obj|属于key-value类型，索引可以是数字，字符串或数据等等|

### 1.1.2 变量/常量/局部/全局 - 数据

数据在使用前需要声明，用来创建该数据的容器。数据在声明前使用该值无效，只能在声明后使用。
zSlip数据有四种属性：变量，常量，局部数据，全局数据。

变量和常量只能选择其中一种。
局部和全局只能选择其中一种。

变量或常量的声明规则：
  - 开头仅为**字母**或**下划线**，其他字符或数字为无效声明。
  - 字符长度限制为128。

#### 1.1.2-i 局部变量

局部变量的关键字为 **local**，表明该数据仅在当前域内有效，一般在一对大括号中。
该关键字可省略，即为默认属性。

#### 1.1.2-ii 全局变量

全局变量的关键字为 **global**，该值在单个文件中有效。

#### 1.1.2-iii 变量

变量在第一次被声明后，可以任意改变。除了声明为静态类型的数据不能被赋值为其他类型的数据。
声明为变量的数据，需要在声明开头处写上 **let** 的关键字。

```c
// 声明一个局部变量
let a = 1; /* let global a = 1; */

// 声明一个局部变量，该值有效域为当前 **{}** 内
{
    let b = 1;
}

// 声明一个全局变量，该值为静态bool类型，不允许变更
let global bool c = true;
```

#### 1.1.2-iv 常量

常量，在第一次声明后，不允许改变。
声明为常量的数据，需要在声明开头处写上 **const** 的关键字。

```c
// 声明一个局部变量
const a = 'abc'; /* let local a = "abc"; */

// 声明一个局部常量，该值有效域为当前 **{}** 内
{
    const let b = 1;
}

// 声明一个全局常量
const global bool c = true;
```

## 1.2 运算符

运算符是一个特殊的符号，用于告诉解释器执行特定的数学或逻辑运算。zSlip具有以下几种运算符
  - 算术运算符
  - 关系运算符
  - 逻辑运算符
  - 其他运算符

### 1.2.1 算术运算符

设定 **a** 为10，**b** 为20。

|符号|描述|实例|
|---|---|---|
|+|加法|**a+b** 的结果为30|
|-|减法|**a-b** 的结果为-10|
|*|乘法|**a\*b** 的结果为200|
|/|除法|**a/b** 的结果为0|
|%|取余|**a%b** 的结果为10|
|^|乘幂|**a^3** 的结果为1000|
|+=|加且赋值|**a+=b** 的结果为30|
|-=|减且赋值|**b-=a** 的结果为10|
|*=|乘且赋值|**a\*=b** 的结果为200|
|/=|除且赋值|**b/=a** 的结果为2|
|%=|取余且赋值|**b%=a** 的结果为0|
|^=|求幂且赋值|**b^=2** 的结果为400|
|--|自减|**a--** 或 **--a** 等效于 **(a-1)** ,结果为9|
|++|自加|**b++** 或 **++b** 等效于 **(b+1)** ,结果为21|

#### 1.2.1-i infinite 计算

```c
const a = 1 + infinite;          // a = infinite
const a = infinite + infinite;   // a = infinite
{
    let a = 1;
    a += infinite;               // a = infinite
}
{
    let a = infinite;
    a++;                         // a = infinite
}

const b = 1 - infinite;          // b = -infinite
const b = infinite - infinite;   // b = 0
{
    let b = 1;
    b -= infinite;               // b = -infinite
}
{
    let b = infinite;
    b--;                         // b = infinite
}

const c = -infinite + infinite;  // c = 0

const d = 10 * infinite;         // d = infinite
const d = infinite * infinite;   // d = infinite
{
    let d = 10;
    d *= infinite;               // d = infinite
}

const e = 10 / infinite;         // e = 0
const e = infinite / 10;         // e = infinite
{
    let e = 10;
    e /= infinite;               // e = 0
}

const f = 10 % infinite;         // f = 10
const f = infinite % 10;         // error
{
    let f = 10;
    f %= infinite;               // f = 10
}

const g = 1 ^ infinite;          // g = 1
const g = 0 ^ infinite;          // g = 0
const g = 2 ^ infinite;          // g = infinite
const g = -1 ^ infinite;         // error
{
    let g = infinite;
    g ^= 0;                      // g = 1
    g ^= 3;                      // g = infinite
    g ^= -1;                     // g = 0
}
```

#### 1.2.1-ii 除法运算符 /

运算前的前后两个数据为 **num** 类型，结果同为 **num** 类型，即都是整数，且小数部分全部舍去。
运算前的前后两个数据至有一个为 **float** 类型，结果则为 **float** 类型。

```c
const a,b = 10,21;
const c = b / a;   // c = 2

const a,b = 10,21.0;
const c = b / a;  // c = 2.1
```

另外,当除数为0时，输出 **infinite** 关键字表示无穷大。

```c
const c = 10 / 0; // c = infinite
```

#### 1.2.1-iii 取余运算符 %

该运算符仅对整数有效

### 1.2.2 关系运算符

|符号|描述|实例|
|---|---|---|
|==|判断两个值是否相等|(10 == 10.1) false|
|\!=|判断两个值是否不相等|('abc' != 20) true|
|>|判断左边的值是否大于右边的值|(20.1 > 10) true|
|>=|判断左边的值是否大于等于右边的值|(123 >= 10) true|
|<|判断左边的值是否小于右边的值|(10 < 20) true|
|<=|判断左边的值是否小于等于右边的值|(10 <= 5) false|

#### 1.2.2-i 等于运算符 ==

该运算符可以判断以下几种情况
  - 位与位
  - 字节与字节
  - 字节与整数
  - 字节与浮点数
  - 整数与整数
  - 整数与浮点数
  - 浮点数与浮点数
  - 字符串与字符串
  - map与map
  - 类型与类型

#### 1.2.2-ii 不等于运算符 !=

该运算符可以判断以下几种情况
  - 位与位
  - 字节与字节
  - 整数与整数
  - 整数与浮点数
  - 浮点数与浮点数
  - 字符串与字符串
  - map与map
  - 类型与类型

#### 1.2.2-iii 大于，大于等于，小于，小于等于运算符

该运算符可以判断以下几种情况
  - 位与位
  - 字节与字节
  - 整数与整数
  - 整数与浮点数
  - 浮点数与浮点数
  - 字符串与字符串

### 1.2.3 逻辑运算符

|符号|描述|实例|
|---|---|---|
|&& and|逻辑与操作符|(true and false)  false|
|\|\| or|逻辑或操作符|(true || false) true|
|! not|逻辑非操作符|(! true) false|

### 1.2.4 其他运算符

|符号|描述|
|---|---|
|..|截取运算符|
|$|字符串插入数据运算符|
|+|字符串拼接运算符|
|.|点运算符|

#### 1.2.4-i 截取运算符

使用方式：
a. 字符串
str[a..b],表示从字符串str中，从第a位开始，截取b个字节，当a+b超过字符串长度时，只截取到字符串的最后一个字符。
  - a，表示从第几位开始，可省略,表示第0位。
  - b，表示截取多少个字符，可省略，表示截取到字符串尾。
    - ^b，表示从字符串倒数第几个开始截取，截取a个字符，当a+b超过字符串长度时，只截取到字符串的第一个字符。
    - ^，表示从最后一个字符开始截取，截取a个字符。

```c
const a = '0123456789';
const b = a[0..2];      // 表示从字符串第0位开始，取两个字符，即 b = '01'
const c = a[3..];       // 表示从字符串第3位开始，取到字符串最后，即 c = '3456789'
const d = a[..4];       // 等价于从字符串第0位开始，取四个字符，即 d = '0123'
const f = a[3..^2];     // 表示从字符串倒数第2位开始，取3个字符，即 f = '567'
const g = a[1..^];      // 等价于从字符串倒数第0位开始，取1个字符，即 g = '9'
const h = a[..];        // 等于截取全部字符串，即 h = '0123456789'
```

b. 数组
array[a..b],表示从数组中，从第a个数据开始，获取b个数据，当a+b超过数组有效长度后，只获取到最后一个数据。
  - a，表示从第几个开始，可省略,表示第0个。
  - b，表示截取多少个数据，可省略，表示截取到最后一个数据。
    - ^b，表示从数组倒数第几个开始截取，截取a个数据，当a+b超过数据有效长度时，只获取到最后一个数据。
    - ^，表示从最后一个数据开始截取，截取a个数据。

```c
const a = [0,1,2,3,4,5,6,7,8,9];
const b = a[1..2];      // 从第1个数据开始，获取两个数据，即 b = [1,2]
const c = a[3..];       // 表示从数据第3位开始，取到数据最后，即 c = [3，4，5，6，7，8，9]
const d = a[..4];       // 等价于从数据第0位开始，取四个字符，即 d = [0，1，2，3]
const f = a[3..^2];     // 表示从数据倒数第2位开始，取3个字符，即 f = [5，6，7]
const g = a[1..^];      // 等价于从数据倒数第0位开始，取1个字符，即 g = [9]
const h = a[..];        // 等于截取全部数据，即 h = [0,1,2,3,4,5,6,7,8,9]
```

#### 1.2.4-ii 字符串插入数据运算符

格式：$'abc {val}' 或 $"456 {val}"

```c
const a = 10;
const str = $'Number : {a}';    // 常量str的值位 "Number : 10"
```

#### 1.2.4-iii 字符串拼接运算符

格式: 字符串 + 字符串 或 字符串 + 数字
禁止：数字 + 字符串

```c
const str1 = 'a' + 'b';    // str1 = 'ab'
const str2 = str1 + 'c';   // str2 = 'abc'
const str3 = '123';
const str4 = str2 + str3;  // str4 = 'abc123'
const str5 = str2 + 123;   // str5 = 'abc123'
const val = 123;
const str6 = str2 + val;   // str6 = 'acb123'

const str_e = 123 + 'abc'; // error
```

#### 1.2.4-v 点运算符

|具体功能|描述|
|---|---|
|.count()|成员数量|
|.size()|容器中数据大小|
